function is_forward(token, rules, route="") {
    for(let i=0; i<rules[token].length; i++) {
        if(rules[token][i] == "f") {
            return true;
        } else if(rules[token][i] != "+" && rules[token][i] != "-" && rules[token][i] != token && route.indexOf(rules[token][i]) == -1) {
            if(is_forward(rules[token][i], rules, route+rules[token][i])) {
                return true;
            }
        }
    }
    return false;
}

// Build a copy of the rules without the rules that make no forward action
function pureCopy(rules) {
    let pureRules = {};
    pureRules['S'] = rules['S'];
    let banned = [];
    // Only add rules that make forward action or call forward rules
    for(let key in rules) {
        if(is_forward(key, rules)) {
            pureRules[key] = rules[key];
        } else {
            banned.push(key);
        }
    }
    // Remove references of non forward rules in the forward rules
    for(let i=0; i<banned.length; i++) {
        for(let key in pureRules) {
            pureRules[key] = pureRules[key].split(banned[i]).join('');
        }
    }
    return pureRules;
}

// Return a function of order the that will give the line count generated by this set of rules
function fcount(rulesref) {
    let rules = pureCopy(rulesref);
    // First, build recursiveM = matrix that stores for ij = the number of times rule j is referenced in rule i
    let recursiveM = new Matrix2D(null, Object.keys(rules).length, Object.keys(rules).length);
    // Set every values to zero (preparing to count)
    for(let i=0; i<Object.keys(rules).length; i++) {
        recursiveM.values[i][i] = 0;
    }
    // A identity matrix, same size as recursiveM
    let id = new Matrix2D(null, Object.keys(rules).length, Object.keys(rules).length);
    // bi-Mapping each rule to a number (using a simple array)
    let rulelist = [];
    let rulemap = {};
    let empty = [];
    for(let key in rules) {
        rulemap[key] = rulelist.length;
        rulelist.push(key);
        empty.push([0]);
    }
    // Vector that stores the number of f in each rules
    let fvect = new Matrix2D(empty);
    for(let i=0; i<rulelist.length; i++) {
        fvect.values[i][0] = 0;
        for(let j=0; j<rules[rulelist[i]].length; j++) {
            if(rules[rulelist[i]][j] == "f") {
                fvect.values[i][0] ++;
            } else if(rules[rulelist[i]][j] != "+" && rules[rulelist[i]][j] != "-") {
                recursiveM.values[i][rulemap[rules[rulelist[i]][j]]] ++;
            }
        }
    }
    let lefttemp = id.sub(recursiveM);
    let leftcomponent = lefttemp.inv();
    return function(order) {
        let temp1 = recursiveM.pow(order);
        let temp2 = id.sub(temp1);
        let temp3 = leftcomponent.mult(temp2);
        let resmatrix = temp3.mult(fvect);
        // Sum the component of S
        let sum = 0;
        for(let i=0; i<recursiveM.values[rulemap['S']].length; i++) {
            sum += resmatrix.values[i]*recursiveM.values[rulemap['S']][i];
        }
        sum += fvect.values[rulemap['S']][0];
        return Math.round(sum);
    };
}
